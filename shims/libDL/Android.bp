//
// libdl
//
cc_library {
    name: "libDL",

    vendor: true,
    defaults: ["linux_bionic_supported"],

    // NOTE: --exclude-libs=libgcc.a makes sure that any symbols libdl.so pulls from
    // libgcc.a are made static to libdl.so.  This in turn ensures that libraries that
    // a) pull symbols from libgcc.a and b) depend on libdl.so will not rely on libdl.so
    // to provide those symbols, but will instead pull them from libgcc.a.  Specifically,
    // we use this property to make sure libc.so has its own copy of the code from
    // libgcc.a it uses.
    //
    // DO NOT REMOVE --exclude-libs!

    ldflags: ["-Wl,--exclude-libs=libgcc.a"],

    arch: {
        arm: {
            version_script: "libdl.arm.map",
            ldflags: ["-Wl,--hash-style=both"],
        },
    },
    srcs: ["libdl.c", "placeholder.c"],
    cflags: [
        "-Wall",
        "-Wextra",
        "-Wunused",
        "-Werror",
    ],
    stl: "none",

    // NOTE: libdl needs __aeabi_unwind_cpp_pr0 from libgcc.a but libgcc.a needs a
    // few symbols from libc. Using --no-undefined here results in having to link
    // against libc creating a circular dependency which is removed and we end up
    // with missing symbols. Since this library is just a bunch of stubs, we set
    // LOCAL_ALLOW_UNDEFINED_SYMBOLS to remove --no-undefined from the linker flags.
    allow_undefined_symbols: true,
    system_shared_libs: [],

    // For private/CFIShadow.h.
    //include_dirs: ["bionic/libc"],

    // This is placeholder library the actual implementation is (currently)
    // provided by the linker.
    shared_libs: [ "ld-android" ],

    sanitize: {
        never: true,
    },
}

ndk_library {
    name: "libDL",
    symbol_file: "libdl.map.txt",
    first_version: "9",
}

llndk_library {
    name: "libDL",
    symbol_file: "libdl.map.txt",
}
